{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1th function\n",
      "minf=6.599157518022159e-26|gradf|=2.1949952095092286e-12mineig=1.4327634322313259iter=15\n",
      "2th function\n",
      "minf=0.39226791131401634|gradf|=1.1802115571912624mineig=-7.253218379135008iter=200\n",
      "3th function\n",
      "minf=1.1279327696190214e-8|gradf|=2.469275154190461e-16mineig=0.1396543631732198iter=3\n",
      "4th function\n",
      "minf=1.130024585055066e-6|gradf|=0.018724568541661882mineig=5.279332249259749e-6iter=200\n",
      "5th function\n",
      "minf=4.966926975238465e-12|gradf|=9.560748608590294e-8mineig=0.0009115860642162575iter=16\n",
      "6th function\n",
      "minf=2219.8508439334814|gradf|=1200.3642986572452mineig=-70694.56652325219iter=200\n",
      "7th function\n",
      "minf=12.681809249772067|gradf|=76.33620284867975mineig=-179.2753753355934iter=200\n",
      "8th function\n",
      "minf=0.0005426827487042476|gradf|=0.008473968098162676mineig=0.016969766652955513iter=17\n",
      "9th function\n",
      "minf=88.05320581802117|gradf|=0.4713919111528313mineig=-11.318315196090198iter=200\n",
      "10th function\n",
      "minf=1.3590842481722266e-20|gradf|=1.2379874905192022e-5mineig=1.9999999999999998iter=6\n",
      "11th function\n",
      "minf=1.620366948060184e6|gradf|=491395.3742703368mineig=-3926.871329563959iter=200\n",
      "12th function\n",
      "minf=2.782877264353357e-6|gradf|=8.897461275093429e-6mineig=1.4426373067822371e-5iter=200\n",
      "13th function\n",
      "minf=2.821674512748804e-7|gradf|=0.0005096369459231224mineig=-0.03480351039227232iter=200\n",
      "14th function\n",
      "minf=461.3480161605121|gradf|=1008.6658645191269mineig=-681.6248459628891iter=200\n",
      "15th function\n",
      "minf=3015.2466367834822|gradf|=1694.1159810112267mineig=-673.6739853860475iter=200\n",
      "16th function\n",
      "minf=4.228933478621659e-24|gradf|=1.8703681633907943e-11mineig=0.30146364652786684iter=8\n",
      "17th function\n",
      "minf=1.8225363181717792e-19|gradf|=1.2747547318240412e-8mineig=0.7195680859133333iter=39\n",
      "18th function\n",
      "minf=0.010508350801588302|gradf|=1.7990083707783475mineig=-214.35745402936263iter=200\n"
     ]
    }
   ],
   "source": [
    "##### HW 4 newton method with modified Hessian\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "using Toms566\n",
    "\n",
    "\n",
    "\n",
    "function newtmin( obj, x0; maxit=200, optTol=1e-9)\n",
    "# Minimize a function f using Newtonâ€™s method.\n",
    "# obj: a function that evaluates the objective value,\n",
    "# gradient, and Hessian at a point x, i.e.,\n",
    "# (f, g, H) = obj(x)\n",
    "# x0: starting point.\n",
    "# maxIts (optional): maximum number of iterations.\n",
    "# optTol (optional): optimality tolerance based on\n",
    "# ||grad(x)|| <= optTol*||grad(x0)||\n",
    "    \n",
    "    f_0 = obj.obj(x0);\n",
    "    grad_0 = obj.grd(x0);\n",
    "    Hes_0 = obj.hes(x0);\n",
    "    Hes_0 = Hes_0-min(eigmin(Hes_0)-1e-3,0)*eye(length(x0));\n",
    "        \n",
    "    x = x0;\n",
    "    f_x = f_0;\n",
    "    grad_x = grad_0;   \n",
    "    Hes_x = Hes_0;\n",
    "    \n",
    "    #Counts the iteratives.\n",
    "    int = 0;\n",
    "    \n",
    "    while optTol * norm(grad_0,2) <= norm(grad_x,2)\n",
    "        \n",
    "        int=int+1;\n",
    "        # if the iteratives number is greater than maxit, break down.\n",
    "        if int >= maxit\n",
    "            break\n",
    "        end\n",
    "        \n",
    "    # applying netwon method\n",
    "    \n",
    "    # determine the direction.\n",
    "    \n",
    "        dx = - inv(Hes_x) *  grad_x ;\n",
    "    \n",
    "        t=1;\n",
    "        bt=0;\n",
    "        at=grad_x' * dx;\n",
    "\n",
    "            while obj.obj(x+t*dx) >= obj.obj(x)+alpha*t*at[1]\n",
    "        \n",
    "                t= t * beta;\n",
    "            end # back tracking\n",
    "        \n",
    "        \n",
    "        x=x+dx*t;\n",
    "    \n",
    "        f_x=obj.obj(x);\n",
    "        grad_x = obj.grd(x);\n",
    "        Hes_x = obj.hes(x);\n",
    "        Hes_x = Hes_x - min(eigmin(Hes_x)-1e-3,0)*eye(length(x0));\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    end # while newton M\n",
    "    \n",
    "    return(x, int)   \n",
    "end   # function\n",
    "##############################\n",
    "###### The first problem\n",
    "##############################\n",
    "beta = 0.5;\n",
    "alpha = 0.3;\n",
    "for i = 1:18\n",
    "    println(i,\"th function\")\n",
    "    p=Problem(i)\n",
    "    x0=p.x0;\n",
    "    (x,int)=newtmin(p,x0)\n",
    "    println(\"minf=\", p.obj(x),\"|gradf|=\",norm(p.grd(x),2),\"mineig=\",eigmin(p.hes(x)),\"iter=\",int)\n",
    "end\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 0.5.0-dev",
   "language": "julia",
   "name": "julia-0.5"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "0.5.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
